# TASA - Translation And Structural Alignment (v1.1.2)

TASA is a [React](https://reactjs.org) web application for translating
and aligning sentence pairs.

## Prerequisites

TASA is built using [Node.js](https://nodejs.org/en/) and the Node
Package Manager, [npm](https://docs.npmjs.com).

Once you have Node and npm installed, go to the `webapp/` directory
and run the command:

    npm install

This will download the dependencies specified in
[webapp/package.json](webapp/package.json) to the
`webapp/node_modules/` directory.

## Building

Inside the `webapp/` directory, the TASA HTML templates is generated
using the command:

    npm run buildTemplates

This will create a React web application in the `webapp/build/`
directory, and generate `webapp/anno-app-{turkle|mturk}.html`.

## Using TASA with Turkle or Mechanical Turk

The repo contains scripts for creating Turk-compatible HTML templates
for the React web application.  Neither Mechanical Turk nor
[Turkle](https://github.com/hltcoe/turkle) allow users to upload
static CSS or JS files for an HTML template.  All of the CSS and JS
files required by a Turk template must either be inserted into the
HTML template file or published on public CDNs.

TASA has separate scripts for generating
Mechanical Turk and Turkle templates.  Both scripts insert the
React JavaScript files  into the HTML template.

- The [webapp/make-turkle-template.sh](webapp/make-turkle-template.sh)
  script copies built CSS and JS bundles into the HTML template
  [webapp/anno-app-turkle.html](webapp/anno-app-turkle.html).

- The [webapp/make-mturk-template.sh](webapp/make-mturk-template.sh)
  script copies built CSS and JS bundles into the HTML template
  [webapp/anno-app-mturk.html](webapp/anno-app-mturk.html).
  Note that the Mechanical Turk website has a size limit for HTML
  templates, this script simply copies the CSS and JS contents into 
  HTML templates. If current HTML template file exceeds the size limit, 
  upload the CSS and JS files generated by `npm build` to a CDN, 
  and link their URLs in the HTML template file to reduce the size of 
  template.

Before running TASA on Turkle, adjust the HTML template size limit
by editing this setting in `turkle_site/settings.py` on local install. [ref](https://gitlab.hltcoe.jhu.edu/research/turkle/issues/217)
```python
# max size of template in KB
TURKLE_TEMPLATE_LIMIT = 1024 # default is 64. change it to 1024
```
Also please read this [document](https://github.com/hltcoe/turkle/blob/master/docs/TEMPLATE-GUIDE.md) 
about how the Turkle template variables work for your first time working with Turkle.

## Running TASA independently

You may run TASA on your local machine in developement using the command:

    npm start

This command will open up a development server on port 3000. You may edit the 
React code and simlutaneously see how the UI changes. It is useful when you want
to develop new feature, as you don't need to load the template into Turkle for 
every change you made. In this mode, TASA uses the sentence pair and configuration
 data stored in `webapp/src/mock.json` as input and renders the UI accordingly. 


### CSV format for Turk templates

The Turk HTML templates are designed to work with a CSV file with the
fields:

- `src_tokens` - A JSON array of tokenized source sentence. 
- `tar_tokens` - A JSON array of tokenized target sentence. 
- `config_obj` - A JSON object containing the following entries. 
  **Leave out the entry name if it is unused, TASA will automatically use the default value**.
  - `alignment` - One could set initial alignments, so annotator could 
    begin with automatically produced results. It is a JSON boolean 
    "matrix" (list of lists) where each value in the sublist is either 
    `true` or `false`.  If `src_tokens` has a sentence with E tokens
    and `tar_tokens` has a sentence with Z tokens, then `alignment` is a
    list with E sublists, and each sublist has Z values, where each
    value is either `true` or `false`.
  - `src_enable_retokenize` - Either `true` or `false`
  - `tar_enable_retokenize` - Either `true` or `false`
  - `src_spans` - Source side substring spans that should be highlighted.
    It must be sorted with ascending order, and not contain any overlap.
    The format is a list of length-2 lists `[begin, end]`, where `begin` is
    inclusive, while `end` is exclusive.
  - `tar_spans` - Same as above, for target side highlight spans.
  - `src_head_inds` - A JSON array of token indices. Only tokens
    in this list can be aligned with tokens in the target sentence.
  - `tar_head_inds` - A JSON array of token indices.  Only tokens
    in this list can be aligned with tokens in the source sentence.
  - `src_text_dir` [string]: Set
     [HTML text direction property](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir)
     for source sentence, determining whether source tokens are
     displayed left-to-right (for languages like English) or
     right-to-left (for languages like Arabic).  Possible values are
     `auto`, `ltr` and `rtl`.  Default: `auto`.
  - `tar_text_dir` [string]: Set
     [HTML text direction property](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir)
     for target sentence, determining whether target tokens are
     displayed left-to-right (for languages like English) or
     right-to-left (for languages like Arabic).  Possible values are
     `auto`, `ltr` and `rtl`.  Default: `auto`.
  - `font_size` - A string to control tokens font size. Use the follwoing 
  - `gold_alignment` - A JSON boolean "matrix" same as `alignment`. Add
    this field for annotator training, usually only the first 5~10 sentences
    will have this field. Itstores the gold alignment of given `src_tokens` 
    and `tar_tokens`. 
  - `translation_quality_scale` - A integer for the scale of translation
    quality feedback, please set the default value to 100. Adding this 
    attribute to `config_obj` will create a new column in the output CSV 
    file named `additionalData`. Right now slider widget is used to collect
    feedback from annotators, if in the future binary feedback is desired, 
    make use of the out-of-shelf CheckBox widget left commented in 
    `webapp/src/QualityFeedback.js`.
  - `collect_comment` - Either `true` or `false`. This is a boolean value
    to indicate whether to collect comment from annotators. Adding this
    attribute to `config_obj` will create a new column in the output CSV
    file named `additionalData`.


For example CSV files, see
- [test_20_span_head_font.csv](test_20_config_full.csv). - An example of CSV file
 that sets `{src|tar}_spans`, `{src|tar}_head_inds`, `font_size`.
- [test_20_retok.csv](test_20_retok.csv). - An example of CSV file that sets 
 `{src|tar}_enable_retokenize`.
- [test_20_annotator_training.csv](test_20_annotator_training.csv). - An exmaple
 of CSV file that sets `gold_alignment` for annotator training. 
- [test_20_scale.csv](test_20_scale.csv). - An example of CSV file that sets
 `translation_quality_scale` to collect translation feedback from annotators. 

-----
## TASA structure 

Read this part when you are going to develop new features or maintain TASA.

The below figure illustrate the three components in the scenario of running 
TASA running on Turkle: React code, HTML template, Turkle CSV.

![tasa structure](./figure/tasa_structure.jpg)

React code is written with the assumption of variables store in the window
object. `window.src_tokens`, `window.tar_tokens`, `window.config_obj` will be 
properly assigned during the variable injection in the HTML template. These
variables embedded in `window` will be the data source, and the responsibility
of React code is data manipulation and visualization. The React code only sees
one individual row in Turkle CSV, and render the UI accordingly.

HTML template is composed of the variable injection part, and an empty `<div>` 
with inline CSS & JS. When this HTML template is loaded by a browser (to be more 
specific, inside the `<iframe>` of Turkle), first the variable injection part 
will receive template variables from Turkle, and assign the content of template 
variables to `window`. Then the inline JS code will execute, accessing variables
injected inside `window`, creating DOM elements inside the empty `<div>`, and 
apply style to these new DOM elements from inline CSS.

Turkle CSV is the data source. The format of Turkle CSV is explained above.

## Contributors
Listed in order of contribution:
- [Tzu-Ray Su](https://github.com/ray1007)
- [Elias Stengel-Eskin](https://github.com/esteng) 

